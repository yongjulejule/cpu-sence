# CPU 연산별 리소스 사용량 분석 리포트

## 1. 개요

이 리포트는 기본 CPU 연산들의 리소스 사용량을 분석하여 Node.js 백엔드 및 DevOps 관점에서 vCPU 사용량을 예측하기 위한 기초 자료입니다. 각 연산별 CPU 사용량 프로파일을 통해 실제 애플리케이션 설계 시 필요한 리소스를 효과적으로 산정할 수 있습니다.

## 2. 연산별 vCPU 사용량 분석

### 2.1 기본 연산 (1 vCPU 기준)

| 연산 유형      | 실행 시간(초) | CPU 점유율(%) | 초당 처리 가능 연산 | vCPU 100% 사용 시 QPS 예상치 |
| -------------- | ------------- | ------------- | ------------------- | ---------------------------- |
| 정수 연산      | 7.53          | 100%          | 0.133               | 133                          |
| 실수 연산      | 9.14          | 100%          | 0.109               | 109                          |
| 단순 반복문    | 7.47          | 100%          | 0.134               | 134                          |
| 분기 예측 가능 | 48.99         | 100%          | 0.020               | 20                           |
| 분기 예측 불가 | 49.38         | 100%          | 0.020               | 20                           |
| 메모리 할당    | 0.33          | 99.8%         | 3.03                | 3,030                        |

### 2.2 연산 비용 세부 분석

#### 정수 vs 실수 연산

- 정수 연산은 1 vCPU에서 초당 약 133회 처리 가능
- 실수 연산은 1 vCPU에서 초당 약 109회 처리 가능
- **실무 해석**: 복잡한 수학 연산이 많은 API는 기본 연산보다 약 20-30% 더 많은 CPU 리소스 필요

#### 조건 분기 연산

- 분기 예측 가능/불가능 연산은 1 vCPU에서 초당 약 20회 처리 가능
- 브랜치 미스는 전체 성능에 약 0.8% 추가 지연 발생
- **실무 해석**: 복잡한 조건 분기를 포함한 라우팅 로직은 단순 연산의 약 6-7배 CPU 리소스 소모

#### 메모리 연산

- 메모리 할당은 1 vCPU에서 초당 약 3,030회 처리 가능
- 그러나 페이지 폴트가 많이 발생하면 성능이 크게 저하됨
- **실무 해석**: 대량의 객체 생성은 단일 연산으로는 빠르지만, 누적 효과와 GC 오버헤드 고려 필요

## 3. 실제 Node.js 애플리케이션에 적용

### 3.1 요청당 CPU 비용 계산 예시

**가정된 API 엔드포인트 구성:**

- JSON 파싱 (≈ 정수 연산)
- 비즈니스 로직 계산 (≈ 실수 연산 + 분기)
- 메모리 할당 (객체 생성)

| 요청 구성                               | CPU 비용      | 1 vCPU에서 초당 처리량 |
| --------------------------------------- | ------------- | ---------------------- |
| 경량 API (파싱 + 간단 로직)             | 0.0085초/요청 | ~118 QPS               |
| 중량 API (파싱 + 복잡 로직 + 조건 분기) | 0.0585초/요청 | ~17 QPS                |
| 데이터 집약 API (위 + 대량 메모리 할당) | 0.0618초/요청 | ~16 QPS                |

### 3.2 클라우드 리소스 산정 예시

**500 QPS 처리를 위한 vCPU 필요량:**

- 경량 API: 500 / 118 ≈ 4.2 vCPU
- 중량 API: 500 / 17 ≈ 29.4 vCPU
- 데이터 집약 API: 500 / 16 ≈ 31.3 vCPU

**실무 권장 설정 (20% 여유 포함):**

- 경량 API: 6 vCPU (예: 3개의 t3.medium 인스턴스)
- 중량 API: 36 vCPU (예: 9개의 t3.xlarge 인스턴스)
- 데이터 집약 API: 38 vCPU (예: 5개의 c5.4xlarge 인스턴스)

## 4. CPU 사용량 최적화 전략

### 4.1 연산 최적화

- **정수 연산 선호**: 가능한 경우 실수 연산 대신 정수 연산 사용
- **분기 최소화**: 복잡한 조건 분기를 단순화하거나 예측 가능한 패턴으로 리팩토링
- **메모리 풀링**: 객체 재사용으로 메모리 할당 줄이기

### 4.2 코드 구조 최적화

- **루프 언롤링**: 반복 구조를 최적화하여 분기 오버헤드 줄이기
- **불필요한 재귀 제거**: 꼬리 재귀나 반복문으로 대체
- **메모리 지역성 개선**: 관련 데이터를 가까운 메모리에 배치하여 캐시 효율 향상

## 5. 결론 및 추천 사항

### 5.1 리소스 산정 원칙

- **연산 프로필링**: 각 API 엔드포인트의 연산 패턴 분석
- **측정 기반 접근**: 실제 부하 테스트로 vCPU 사용량 검증
- **여유율 적용**: 최소 20%의 CPU 여유를 두어 버스트 트래픽 대응

### 5.2 클라우드 리소스 구성 추천

- **오토스케일링 설정**: 평균 CPU 사용률 70%를 목표로 설정
- **인스턴스 유형 선택**: 계산 집약적 작업은 c 계열, 범용은 t 계열 인스턴스
- **컨테이너 리소스 제한**: 측정된 CPU 사용량에 기반하여 컨테이너당 CPU 제한

이 분석을 통해 1 vCPU에서 어떤 연산이 얼마나 처리 가능한지 기초 데이터를 확보했습니다. 실제 애플리케이션에서는 이러한 기본 연산들의 복합적인 조합으로 CPU 리소스를 소비하므로, 이 데이터를 바탕으로 복잡한 API의 리소스 요구사항을 예측할 수 있습니다.
