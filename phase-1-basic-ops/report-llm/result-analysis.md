## Phase 1 단계별 결과 분석

### 1단계: 정수 vs 실수 연산 (1-integer-vs-float)

| 테스트      | 실행 시간 | IPC(명령어/사이클) | 스톨 비율 | 브랜치 미스 비율 |
| ----------- | --------- | ------------------ | --------- | ---------------- |
| integer_ops | 7.53초    | 0.79               | 0.17      | 0.15%            |
| float_ops   | 9.14초    | 1.46               | 0.21      | 0.11%            |

**주요 발견점**:

- 실수 연산이 정수 연산보다 약 21% 더 오래 걸립니다
- 그러나 실수 연산의 IPC가 훨씬 높습니다(1.46 vs 0.79) → FPU의 병렬 처리 능력 때문
- 프론트엔드 스톨(명령어 fetch 대기)은 실수 연산에서 극히 낮음(0.08% vs 12.28%)
- 백엔드 스톨(실행 대기)은 실수 연산에서 훨씬 높음(31.22% vs 11.84%)

**실무적 의미**: 부동소수점 연산은 정수보다 시간이 더 걸리지만, 현대 CPU의 병렬 처리 덕분에 효율적으로 처리됩니다.

### 2단계: 반복문, 분기, 재귀 (2-loop-branch-recursion)

| 테스트               | 실행 시간 | IPC   | 브랜치 미스 비율 | 특이사항                           |
| -------------------- | --------- | ----- | ---------------- | ---------------------------------- |
| loop_simple          | 7.47초    | 0.74  | 0.13%            | 기준이 되는 단순 반복문            |
| iterative_sum        | 0.012초   | 0.68  | 1.88%            | 매우 빠른 실행                     |
| recursive_sum        | 0.018초   | 7.82  | 6.21%            | 높은 IPC, 높은 브랜치 미스         |
| branch_predictable   | 48.99초   | 1.16  | 0.26%            | 긴 실행시간, 예측 가능한 분기      |
| branch_unpredictable | 49.38초   | 1.24  | 3.16%            | 가장 긴 실행시간, 높은 브랜치 미스 |
| recursion_naive      | 0.012초   | 2.14  | 3.20%            | 높은 IPC, 중간 수준 브랜치 미스    |
| recursion_tail       | 0.008초   | 33.98 | -                | 매우 높은 IPC, 컴파일러 최적화     |

**주요 발견점**:

- 분기 예측 실패 시 성능 저하: branch_unpredictable이 branch_predictable보다 약간 더 느림(+0.39초)
- 분기 미스율: 예측 가능 0.26% vs 예측 불가능 3.16% (약 12배 차이)
- 재귀 함수는 일반적으로 반복문보다 브랜치 미스가 많음
- tail 재귀는 매우 효율적으로 최적화됨(IPC 33.98로 매우 높음)

**실무적 의미**: 예측 가능한 패턴의 코드가 성능에 유리하며, 꼬리 재귀는 컴파일러에 의해 매우 효율적으로 최적화됩니다.

### 3단계: 메모리 연산 (3-memory-operations)

| 테스트       | 실행 시간 | user 시간 | sys 시간 | 페이지 폴트 | 브랜치 미스 비율 |
| ------------ | --------- | --------- | -------- | ----------- | ---------------- |
| memory_alloc | 0.33초    | 0.15초    | 0.18초   | 24,603      | 2.80%            |

**주요 발견점**:

- 시스템 시간(커널 모드)이 사용자 시간(유저 모드)보다 더 많음
- 매우 많은 페이지 폴트 발생(74.372K/sec)
- 다른 테스트에 비해 상대적으로 높은 브랜치 미스율(2.80%)

**실무적 의미**: 메모리 할당은 시스템 콜의 오버헤드와 페이지 폴트로 인해 비용이 발생합니다. 이는 동적 메모리 할당이 빈번한 애플리케이션에서 성능 병목이 될 수 있음을 의미합니다.

## 종합 분석

### 각 단계별 핵심 통찰:

1. **연산 유형(정수 vs 실수)**:

   - 실수 연산은 더 많은 시간이 걸리지만, 현대 CPU는 병렬 처리로 효율성을 높임
   - IPC 측정은 단순 시간 측정보다 CPU 효율성을 더 잘 보여줌

2. **흐름 제어(반복/분기/재귀)**:

   - 브랜치 예측은 성능에 중요한 영향을 미침
   - 예측 불가능한 분기는 파이프라인 스톨을 증가시킴
   - 컴파일러는 특정 패턴(꼬리 재귀)에서 놀라운 최적화 능력을 보여줌

3. **메모리 관리**:
   - 메모리 할당은 시스템 콜과 페이지 폴트로 인한 오버헤드가 있음
   - 많은 페이지 폴트는 성능 저하의 원인이 될 수 있음

이런 단계별 결과를 바탕으로 애플리케이션 성능 최적화 전략을 세울 수 있습니다. 예를 들어, 메모리 풀링을 사용하여 할당 오버헤드를 줄이거나, 예측 가능한 코드 패턴을 사용하여 분기 미스를 최소화하는 등의 방법을 적용할 수 있습니다.
