- 코어가 하난데 왜 cpu-migrations 가 있지? ㅎㅎ
  - IO 걸리면 그럴수있지 씨피유는 바쁘니까.
- 재귀에서 이상한 결과 나옴 (컴파일러 최적화)
  - 0.015724490 seconds time elapsed
  - 0.000000000 seconds user
  - 0.015798000 seconds sys
  - 이런 결과가 나왔는데,어셈 보면 다 계산해둔거임; - Constant Folding 라고 하는듯
- float 연산이 생각보다 차이가 안났는데 이건 IPC 가 높아서 그렇다고 함
  - FPU (float point unit) 이 병렬로 잘 돌아서 그렇다는디
  - 요즘 씨퓨 아키텍쳐는 파이프라인, 슈퍼 스칼라 이런게 있다고 함
  - 파이프라인은 생산라인마냥 여러개의 스테이지로 나뉘어서 각자 할일을 함
  - 슈퍼스칼라는 동일한 파이프라인을 여러개.. .둬서 처리 (대체 어케함??)
  - 암튼 그래서 한 사이클에 여러 명령어가 처리되기도 해서, IPC 가 1보다 커질 수 있는것.
- 뭔 짓을 해도 branch prediction 을 95% 이상 해낸다. 어케하는겨
- branch prediction miss 가 나면? 씨피유님의 원대한 계획이 무너짐

  - 파이프라인이 다 날라가고, 다시 시작해야함
  - 근데? 지표를 보면 branch prediction 에서 stalled-cycles-frontend 가 퍼센트가 더 많음...
  - 하지만 절대적인 수치로 봤을 때 성능은 unprediction 보다 더 빠름
    - stalled-cycles-frontend 의 개수가 압도적으로 많아서 퍼센트가 높게 나오는거임! 그냥 너무 빨라서 백엔드가 병목이 된것
  - 코드 업데이트 해서 다시 해보니 성능 차이가 꽤 발생함
  - 이론적으로 봤을땐 다음과 같음
    - branch-misses 수치 및 비율 증가
    - stalled-cycles-frontend 수치 및 비율 증가 (예측 실패로 인한 파이프라인 플러시 때문에)
    - IPC 감소
    - task-clock (총 실행 시간) 증가

- 메모리 할당은 영... 모르겠음. 게다가 mmap 이런거 쓰지 않나
  - system time 이 확연히 늘어나긴 함
- recursion-tail 에서 isbn 이 34 가 나옴! <- 이거 constant folding 먹어서 연산이 너무 적고, task clock 도 너무 작아서 계산 결과가 잘못 나왔을 가능성이 몹시 높다고 함 (잼민이 피셜)
